    private void ensureDestinationMetadata(PreparedStatement ps) throws SQLException {
        if (destinationSqlTypes != null) {
            return;
        }

        ParameterMetaData pmd = ps.getParameterMetaData();
        int count = pmd.getParameterCount();

        destinationSqlTypes = new int[count];
        for (int i = 1; i <= count; i++) {
            try {
                destinationSqlTypes[i - 1] = pmd.getParameterType(i);
            } catch (SQLException e) {
                // Some drivers (older MySQL) do not support this
                destinationSqlTypes[i - 1] = Types.OTHER;
            }
        }
    }


private void bindRow(PreparedStatement ps, Map<String, Object> row) throws SQLException {

        for (int i = 0; i < destinationColumns.size(); i++) {

            String colName = destinationColumns.get(i);
            Object value = row.get(colName);
            int sqlType = destinationSqlTypes[i];

            bindValue(ps, i + 1, value, sqlType);
        }
    }


private void bindValue(
            PreparedStatement ps,
            int index,
            Object value,
            int sqlType) throws SQLException {

        if (value == null) {
            ps.setNull(index, sqlType);
            return;
        }

        // ------------------------------------------------------------------
        // Binary (BLOB / VARBINARY)
        // ------------------------------------------------------------------
        if (value instanceof byte[] bytes) {
            ps.setBytes(index, bytes);
            return;
        }

        // ------------------------------------------------------------------
        // CLOB / NCLOB
        // ------------------------------------------------------------------
        if (value instanceof String str && isClobType(sqlType)) {
            ps.setCharacterStream(index, new StringReader(str), str.length());
            return;
        }

        // ------------------------------------------------------------------
        // XMLTYPE / SQLXML
        // ------------------------------------------------------------------
        if (value instanceof String str && sqlType == Types.SQLXML) {
            SQLXML xml = connection.createSQLXML();
            xml.setString(str);
            ps.setSQLXML(index, xml);
            return;
        }

        // ------------------------------------------------------------------
        // ARRAY (Oracle / JDBC)
        // ------------------------------------------------------------------
        if (value instanceof Object[] arr && sqlType == Types.ARRAY) {
            Array jdbcArray = connection.createArrayOf("VARCHAR", arr);
            ps.setArray(index, jdbcArray);
            return;
        }

        // ------------------------------------------------------------------
        // STRUCT / UDT (fallback to JSON-style string)
        // ------------------------------------------------------------------
        if (value instanceof Map<?, ?> || value instanceof List<?>) {
            ps.setString(index, value.toString());
            return;
        }

        // ------------------------------------------------------------------
        // Temporal
        // ------------------------------------------------------------------
        if (value instanceof Date date) {
            ps.setDate(index, date);
            return;
        }

        if (value instanceof Timestamp ts) {
            ps.setTimestamp(index, ts);
            return;
        }

        // ------------------------------------------------------------------
        // Default safe binding
        // ------------------------------------------------------------------
        ps.setObject(index, value);
    }



    public void writeBatch(List<Map<String, Object>> rows) throws SQLException {
        if (rows == null || rows.isEmpty()) {
            return;
        }

        try (PreparedStatement ps = connection.prepareStatement(insertSql)) {

            ensureDestinationMetadata(ps);

            for (Map<String, Object> row : rows) {
                bindRow(ps, row);
                ps.addBatch();
            }

            ps.executeBatch();
        }
    }
