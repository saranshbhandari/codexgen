package com.test.dataflowengine.processors.taskprocessors.helpers;

import com.test.dataflowengine.models.tasksettings.subsettings.SourceDestinationMapping;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.sql.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Centralised, optimised datatype conversion between source and destination.
 * Vendor-neutral, safe for DB ↔ DB, DB ↔ File, File ↔ DB.
 */
@Slf4j
public final class DataConverter {

    private DataConverter() {}

    // =====================================================================
    // Conversion plan
    // =====================================================================

    public static final class ConversionPlan {
        private final List<ColumnPlan> columns;
        private ConversionPlan(List<ColumnPlan> columns) { this.columns = columns; }
        boolean isEmpty() { return columns == null || columns.isEmpty(); }
    }

    private static final class ColumnPlan {
        private final String sourceColumnName;
        private final LogicalType targetType;
        private ColumnPlan(String sourceColumnName, LogicalType targetType) {
            this.sourceColumnName = sourceColumnName;
            this.targetType = targetType;
        }
    }

    // =====================================================================
    // Logical types
    // =====================================================================

    private enum LogicalType {
        STRING,
        INTEGER,
        LONG,
        DECIMAL,
        BOOLEAN,
        DATE,
        TIMESTAMP,
        BINARY,      // BLOB / VARBINARY
        JSON,        // JSON / JSONB / Oracle JSON
        XML,         // Oracle XMLTYPE
        ARRAY,       // Oracle ARRAY
        STRUCT,      // Oracle STRUCT
        UNKNOWN
    }

    // =====================================================================
    // Plan preparation
    // =====================================================================

    public static ConversionPlan prepareConversionPlan(
            List<SourceDestinationMapping> mappings,
            String sourceVendor,
            String destVendor) {

        if (mappings == null || mappings.isEmpty()) {
            return new ConversionPlan(Collections.emptyList());
        }

        List<ColumnPlan> cols = new ArrayList<>();

        for (SourceDestinationMapping m : mappings) {
            String src = m.getSourceColumnName();
            if (src == null || src.isBlank()) continue;

            LogicalType dest = inferLogicalType(m.getDestinationColumnType(), destVendor);
            LogicalType srcT = inferLogicalType(m.getSourceColumnType(), sourceVendor);
            LogicalType target = dest != LogicalType.UNKNOWN ? dest : srcT;

            if (target == LogicalType.UNKNOWN || target == LogicalType.STRING) continue;

            cols.add(new ColumnPlan(src, target));
        }

        return new ConversionPlan(Collections.unmodifiableList(cols));
    }

    // =====================================================================
    // Batch conversion
    // =====================================================================

    public static void convertBatchInPlace(
            List<Map<String, Object>> rows,
            ConversionPlan plan) {

        if (rows == null || rows.isEmpty() || plan == null || plan.isEmpty()) return;

        for (Map<String, Object> row : rows) {
            for (ColumnPlan cp : plan.columns) {
                Object raw = row.get(cp.sourceColumnName);
                if (raw == null) continue;

                try {
                    row.put(cp.sourceColumnName, convertToTarget(raw, cp.targetType));
                } catch (Exception ex) {
                    log.trace("Conversion failed for column '{}', value='{}'. Keeping original. Cause={}",
                            cp.sourceColumnName, raw, ex.getMessage());
                }
            }
        }
    }

    // =====================================================================
    // Type inference
    // =====================================================================

    private static LogicalType inferLogicalType(String dbType, String vendor) {
        if (dbType == null) return LogicalType.UNKNOWN;

        String type = dbType.trim();
        if (type.isEmpty()) return LogicalType.UNKNOWN;

        int p = type.indexOf('(');
        if (p > 0) type = type.substring(0, p);
        type = type.toUpperCase(Locale.ROOT);

        if ("JSON".equals(type) || "JSONB".equals(type)) return LogicalType.JSON;
        if ("XMLTYPE".equals(type)) return LogicalType.XML;

        if (vendor != null && vendor.toUpperCase().contains("ORACLE")) {
            if ("ARRAY".equals(type)) return LogicalType.ARRAY;
            if ("STRUCT".equals(type)) return LogicalType.STRUCT;
            if ("BLOB".equals(type)) return LogicalType.BINARY;
            if ("CLOB".equals(type) || "NCLOB".equals(type)) return LogicalType.STRING;
        }

        return switch (type) {
            case "INT", "INTEGER" -> LogicalType.INTEGER;
            case "BIGINT", "LONG" -> LogicalType.LONG;
            case "NUMBER", "DECIMAL", "NUMERIC" -> LogicalType.DECIMAL;
            case "BOOLEAN", "BOOL", "BIT" -> LogicalType.BOOLEAN;
            case "DATE" -> LogicalType.DATE;
            case "TIMESTAMP", "DATETIME" -> LogicalType.TIMESTAMP;
            default -> LogicalType.UNKNOWN;
        };
    }

    // =====================================================================
    // Conversion dispatch
    // =====================================================================

    private static Object convertToTarget(Object v, LogicalType t) {
        return switch (t) {
            case INTEGER -> toInteger(v);
            case LONG -> toLong(v);
            case DECIMAL -> toDecimal(v);
            case BOOLEAN -> toBoolean(v);
            case DATE -> toSqlDate(v);
            case TIMESTAMP -> toSqlTimestamp(v);
            case BINARY -> toBinary(v);
            case JSON -> toJson(v);
            case XML -> toXml(v);
            case ARRAY -> toArray(v);
            case STRUCT -> toStruct(v);
            default -> v;
        };
    }

    // =====================================================================
    // Primitive conversions (same as yours, unchanged)
    // =====================================================================

    private static Integer toInteger(Object v) { return v instanceof Number n ? n.intValue() : Integer.valueOf(v.toString()); }
    private static Long toLong(Object v) { return v instanceof Number n ? n.longValue() : Long.valueOf(v.toString()); }
    private static BigDecimal toDecimal(Object v) { return v instanceof BigDecimal b ? b : new BigDecimal(v.toString()); }
    private static Boolean toBoolean(Object v) { return Boolean.valueOf(v.toString()); }

    // =====================================================================
    // JSON / XML / BINARY / UDT
    // =====================================================================

    private static byte[] toBinary(Object v) {
        if (v instanceof byte[] b) return b;
        if (v instanceof Blob blob) {
            try { return blob.getBytes(1, (int) blob.length()); }
            catch (Exception e) { throw new IllegalArgumentException(e); }
        }
        throw new IllegalArgumentException("Unsupported binary type " + v.getClass());
    }

    private static String toJson(Object v) {
        return v.toString(); // already normalized by reader
    }

    private static String toXml(Object v) {
        return v.toString(); // XMLTYPE already converted to String
    }

    private static List<Object> toArray(Object v) {
        if (v instanceof Object[] arr) return Arrays.asList(arr);
        if (v instanceof Array sqlArray) {
            try { return Arrays.asList((Object[]) sqlArray.getArray()); }
            catch (Exception e) { throw new IllegalArgumentException(e); }
        }
        throw new IllegalArgumentException("Unsupported ARRAY type " + v.getClass());
    }

    private static Map<String, Object> toStruct(Object v) {
        if (v instanceof Struct struct) {
            try {
                Object[] attrs = struct.getAttributes();
                Map<String, Object> map = new LinkedHashMap<>();
                for (int i = 0; i < attrs.length; i++) {
                    map.put("ATTR_" + (i + 1), attrs[i]);
                }
                return map;
            } catch (Exception e) {
                throw new IllegalArgumentException(e);
            }
        }
        throw new IllegalArgumentException("Unsupported STRUCT type " + v.getClass());
    }

    // =====================================================================
    // Date/time (reuse your existing code here – unchanged)
    // =====================================================================

    private static Date toSqlDate(Object v) { return Date.valueOf(v.toString()); }
    private static Timestamp toSqlTimestamp(Object v) { return Timestamp.valueOf(v.toString()); }
}
