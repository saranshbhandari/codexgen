package com.test.dataflowengine.processors.taskprocessors.helpers;

import com.test.dataflowengine.models.tasksettings.subsettings.SourceDestinationMapping;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Centralised, optimised datatype conversion between source and destination.
 *
 * Typical usage in DataTransferTaskProcessor:
 *
 *   String srcVendor  = resolveDbVendor(settings.getSource());
 *   String destVendor = resolveDbVendor(settings.getDestination());
 *
 *   DataConverter.ConversionPlan plan =
 *           DataConverter.prepareConversionPlan(settings.getMappings(), srcVendor, destVendor);
 *
 *   // For every batch (single or parallel) just before writer.writeBatch(batch):
 *   DataConverter.convertBatchInPlace(batch, plan);
 *
 * Keys in the map remain the same (source column names). Only values are converted.
 */
@Slf4j
public final class DataConverter {

    private DataConverter() {
        // utility class
    }

    // ========================================================================
    // Public API
    // ========================================================================

    /**
     * Immutable description of how to convert each column.
     * Safe to share across threads.
     */
    public static final class ConversionPlan {
        private final List<ColumnPlan> columns;

        private ConversionPlan(List<ColumnPlan> columns) {
            this.columns = columns;
        }

        boolean isEmpty() {
            return columns == null || columns.isEmpty();
        }
    }

    /**
     * Per-column conversion info, prepared once per task.
     */
    private static final class ColumnPlan {
        private final String sourceColumnName;
        private final LogicalType targetType;

        private ColumnPlan(String sourceColumnName, LogicalType targetType) {
            this.sourceColumnName = sourceColumnName;
            this.targetType = targetType;
        }
    }

    /**
     * Build a reusable conversion plan for this task.
     *
     * @param mappings     source->destination mappings (from DataTaskSettings)
     * @param sourceVendor e.g. "ORACLE", "MYSQL", "SQLSERVER", may be null for file sources
     * @param destVendor   e.g. "ORACLE", "MYSQL", "SQLSERVER", may be null for file destinations
     */
    public static ConversionPlan prepareConversionPlan(
            List<SourceDestinationMapping> mappings,
            String sourceVendor,
            String destVendor) {

        if (mappings == null || mappings.isEmpty()) {
            return new ConversionPlan(Collections.emptyList());
        }

        List<ColumnPlan> cols = new ArrayList<>();

        for (SourceDestinationMapping mapping : mappings) {
            String srcCol = mapping.getSourceColumnName();
            if (srcCol == null || srcCol.isBlank()) {
                // Typically "only destination has default" columns – no source value to convert
                continue;
            }

            LogicalType destLogical = inferLogicalType(mapping.getDestinationColumnType(), destVendor);
            LogicalType srcLogical  = inferLogicalType(mapping.getSourceColumnType(), sourceVendor);

            // 1) Prefer destination logical type if known
            // 2) Else fall back to source logical type
            LogicalType target = destLogical != LogicalType.UNKNOWN ? destLogical : srcLogical;




            // If still unknown (e.g. VARCHAR on both sides and user didn't give hints),
            // we don't bother converting.
            if (target == LogicalType.UNKNOWN) {
                continue;
            }

            // No need to convert "string-like" columns; DB / writers are happy with a String.
            if (target == LogicalType.STRING) {
                continue;
            }

            cols.add(new ColumnPlan(srcCol, target));
        }

        return new ConversionPlan(Collections.unmodifiableList(cols));
    }

    /**
     * Apply the conversion plan to a batch of rows in-place.
     * Map keys remain the same; only values change.
     */
    public static void convertBatchInPlace(
            List<Map<String, Object>> rows,
            ConversionPlan plan) {

        if (rows == null || rows.isEmpty() || plan == null || plan.isEmpty()) {
            return;
        }

        for (Map<String, Object> row : rows) {
            if (row == null || row.isEmpty()) {
                continue;
            }

            for (ColumnPlan cp : plan.columns) {
                Object raw = row.get(cp.sourceColumnName);
                if (raw == null) {
                    continue;
                }

                try {
                    Object converted = convertToTarget(raw, cp.targetType);
                    row.put(cp.sourceColumnName, converted);
                } catch (IllegalArgumentException ex) {
                    // Intentionally keep original value if conversion fails.
                    log.trace(
                            "Data conversion failed for column '{}', value='{}'. Keeping original. Cause={}",
                            cp.sourceColumnName,
                            raw,
                            ex.getMessage()
                    );
                }
            }
        }
    }

    // ========================================================================
    // Logical types & type inference
    // ========================================================================

    private enum LogicalType {
        STRING,
        INTEGER,
        LONG,
        DECIMAL,
        BOOLEAN,
        DATE,
        TIMESTAMP,
        UNKNOWN
    }

    /**
     * Map DB/vendor specific type name to logical type.
     *
     * dbType examples:
     *   "VARCHAR2(100)", "NUMBER(10,2)", "DATE", "TIMESTAMP(6)", "string", "date"
     * vendor examples:
     *   "ORACLE", "MYSQL", "SQLSERVER"
     */
    private static LogicalType inferLogicalType(String dbType, String vendor) {
        if (dbType == null) {
            return LogicalType.UNKNOWN;
        }

        String type = dbType.trim();
        if (type.isEmpty()) {
            return LogicalType.UNKNOWN;
        }

        // Strip length/precision: VARCHAR2(100) -> VARCHAR2
        int paren = type.indexOf('(');
        if (paren > 0) {
            type = type.substring(0, paren);
        }
        type = type.toUpperCase(Locale.ROOT);

        // Generic hints from config/metadata (works for file sources)
        if ("STRING".equals(type) || "TEXT".equals(type)) {
            return LogicalType.STRING;
        }
        if ("DATE".equals(type)) {
            return LogicalType.DATE;
        }
        if ("DATETIME".equals(type)) {
            return LogicalType.TIMESTAMP;
        }
        if ("TIMESTAMP".equals(type)) {
            return LogicalType.TIMESTAMP;
        }
        if ("BOOL".equals(type) || "BOOLEAN".equals(type)) {
            return LogicalType.BOOLEAN;
        }
        if ("INT".equals(type) || "INTEGER".equals(type)) {
            return LogicalType.INTEGER;
        }
        if ("LONG".equals(type)) {
            return LogicalType.LONG;
        }
        if ("NUMBER".equals(type) || "DECIMAL".equals(type) || "NUMERIC".equals(type)) {
            return LogicalType.DECIMAL;
        }


        if (vendor != null) {
            String v = vendor.toUpperCase(Locale.ROOT);

            // ORACLE
            if (v.contains("ORACLE")) {
                if (type.startsWith("VARCHAR") || type.contains("CLOB") || type.startsWith("CHAR")) {
                    return LogicalType.STRING;
                }
                if (type.startsWith("TIMESTAMP")) {
                    return LogicalType.TIMESTAMP;
                }
                if ("NUMBER".equals(type)) {
                    return LogicalType.DECIMAL;
                }
            }

            // MYSQL
            if (v.contains("MYSQL")) {
                if (type.startsWith("VARCHAR") || type.startsWith("CHAR") || type.contains("TEXT")) {
                    return LogicalType.STRING;
                }
                if ("INT".equals(type) || "MEDIUMINT".equals(type) || "SMALLINT".equals(type)) {
                    return LogicalType.INTEGER;
                }
                if ("BIGINT".equals(type)) {
                    return LogicalType.LONG;
                }
                if ("TINYINT".equals(type)) {
                    // Often used as boolean(0/1); we still treat it as integer here.
                    return LogicalType.INTEGER;
                }
                if (type.startsWith("DECIMAL")
                        || type.startsWith("NUMERIC")
                        || type.startsWith("DOUBLE")
                        || type.startsWith("FLOAT")) {
                    return LogicalType.DECIMAL;
                }
                if ("DATE".equals(type)) {
                    return LogicalType.DATE;
                }
                if (type.startsWith("DATETIME") || type.startsWith("TIMESTAMP")) {
                    return LogicalType.TIMESTAMP;
                }
            }

            // SQL SERVER
            if (v.contains("SQLSERVER") || v.contains("SQL_SERVER") || "MSSQL".equals(v)) {
                if (type.startsWith("VARCHAR")
                        || type.startsWith("NVARCHAR")
                        || type.startsWith("CHAR")
                        || type.contains("TEXT")) {
                    return LogicalType.STRING;
                }
                if ("INT".equals(type) || "SMALLINT".equals(type) || "TINYINT".equals(type)) {
                    return LogicalType.INTEGER;
                }
                if ("BIGINT".equals(type)) {
                    return LogicalType.LONG;
                }
                if (type.startsWith("DECIMAL") || type.startsWith("NUMERIC") || type.startsWith("MONEY")) {
                    return LogicalType.DECIMAL;
                }
                if ("DATE".equals(type)) {
                    return LogicalType.DATE;
                }
                if (type.startsWith("DATETIME")
                        || type.startsWith("SMALLDATETIME")
                        || type.startsWith("DATETIME2")) {
                    return LogicalType.TIMESTAMP;
                }
                if ("BIT".equals(type)) {
                    return LogicalType.BOOLEAN;
                }
            }
        }

        return LogicalType.UNKNOWN;
    }

    // ========================================================================
    // Per-type conversion helpers
    // ========================================================================

    private static Object convertToTarget(Object value, LogicalType target) {
        return switch (target) {
            case STRING -> value.toString();
            case INTEGER -> toInteger(value);
            case LONG -> toLong(value);
            case DECIMAL -> toDecimal(value);
            case BOOLEAN -> toBoolean(value);
            case DATE -> toSqlDate(value);
            case TIMESTAMP -> toSqlTimestamp(value);
            case UNKNOWN -> value;
        };








    }

    private static Integer toInteger(Object value) {
        if (value instanceof Integer integer) {
            return integer;
        }
        if (value instanceof Number number) {
            return number.intValue();
        }

        String text = value.toString().trim();
        if (text.isEmpty()) {
            return null;
        }
        return Integer.valueOf(text);
    }

    private static Long toLong(Object value) {
        if (value instanceof Long longValue) {
            return longValue;
        }
        if (value instanceof Number number) {
            return number.longValue();
        }

        String text = value.toString().trim();
        if (text.isEmpty()) {
            return null;
        }
        return Long.valueOf(text);
    }

    private static BigDecimal toDecimal(Object value) {
        if (value instanceof BigDecimal bigDecimal) {
            return bigDecimal;
        }
        if (value instanceof Number number) {
            return BigDecimal.valueOf(number.doubleValue());
        }

        String text = value.toString().trim();
        if (text.isEmpty()) {
            return null;
        }
        return new BigDecimal(text);
    }

    private static Boolean toBoolean(Object value) {
        if (value instanceof Boolean bool) {
            return bool;
        }

        String text = value.toString().trim().toLowerCase(Locale.ROOT);
        if (text.isEmpty()) {
            return null;
        }

        if ("1".equals(text) || "y".equals(text) || "yes".equals(text) || "true".equals(text)) {
            return Boolean.TRUE;
        }
        if ("0".equals(text) || "n".equals(text) || "no".equals(text) || "false".equals(text)) {
            return Boolean.FALSE;
        }

        return Boolean.valueOf(text);
    }

    // ========================================================================
    // Date / time parsing
    // ========================================================================

    /**
     * Order is important: more common patterns first for performance.
     * Includes ISO, yyyy-MM-dd, US-style MM/dd/yyyy, dd/MM/yyyy, dd-MMM-yyyy.
     */
    private static final List<DateTimeFormatter> DATE_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE,                         // 2024-12-05
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),                // 05/21/2024
            DateTimeFormatter.ofPattern("dd/MM/yyyy"),
            DateTimeFormatter.ofPattern("dd-MMM-yyyy", Locale.ENGLISH)
    );

    /**
     * DateTime patterns for values that contain both date and time.
     * Includes ISO, yyyy-MM-dd HH:mm:ss, US-style MM/dd/yyyy HH:mm:ss, dd-MMM-yyyy HH:mm:ss.
     */
    private static final List<DateTimeFormatter> DATE_TIME_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE_TIME,                    // 2024-12-05T10:22:33
            DateTimeFormatter.ISO_OFFSET_DATE_TIME,
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"),       // 05/21/2024 10:22:33
            DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss", Locale.ENGLISH)
    );

    private static Date toSqlDate(Object value) {
        if (value instanceof Date sqlDate) {
            return sqlDate;
        }
        if (value instanceof java.util.Date utilDate) {
            return new Date(utilDate.getTime());
        }
        if (value instanceof LocalDate localDate) {
            return Date.valueOf(localDate);
        }
        if (value instanceof LocalDateTime localDateTime) {
            return Date.valueOf(localDateTime.toLocalDate());
        }

        String text = value.toString().trim();
        if (text.isEmpty()) {
            return null;
        }

        // Try pure date patterns first
        for (DateTimeFormatter formatter : DATE_FORMATS) {
            try {
                LocalDate parsed = LocalDate.parse(text, formatter);
                return Date.valueOf(parsed);
            } catch (Exception ignored) {
                // Intentionally ignore and try next pattern
            }
        }

        // If the string actually has time, parse and drop time part
        for (DateTimeFormatter formatter : DATE_TIME_FORMATS) {
            try {
                LocalDateTime parsed = LocalDateTime.parse(text, formatter);
                return Date.valueOf(parsed.toLocalDate());
            } catch (Exception ignored) {
                // Intentionally ignore and try next pattern
            }
        }

        try {
            OffsetDateTime odt = OffsetDateTime.parse(text);
            LocalDate localDate = odt.atZoneSameInstant(ZoneId.systemDefault()).toLocalDate();
            return Date.valueOf(localDate);
        } catch (Exception ignored) {
            // Intentionally ignore and throw below
        }

        throw new IllegalArgumentException("Unable to parse DATE from: " + text);
    }

    private static Timestamp toSqlTimestamp(Object value) {
        if (value instanceof Timestamp timestamp) {
            return timestamp;
        }
        if (value instanceof java.util.Date utilDate) {
            return new Timestamp(utilDate.getTime());
        }
        if (value instanceof LocalDateTime localDateTime) {
            return Timestamp.valueOf(localDateTime);
        }
        if (value instanceof LocalDate localDate) {
            return Timestamp.valueOf(localDate.atStartOfDay());
        }

        String text = value.toString().trim();
        if (text.isEmpty()) {
            return null;
        }

        // Try datetime patterns
        for (DateTimeFormatter formatter : DATE_TIME_FORMATS) {
            try {
                LocalDateTime parsed = LocalDateTime.parse(text, formatter);
                return Timestamp.valueOf(parsed);
            } catch (Exception ignored) {
                // Intentionally ignore and try next pattern
            }
        }

        try {
            OffsetDateTime odt = OffsetDateTime.parse(text);
            return Timestamp.from(odt.toInstant());
        } catch (Exception ignored) {
            // Intentionally ignore and try as date-only below
        }

        // Maybe only a date string – treat as midnight
        for (DateTimeFormatter formatter : DATE_FORMATS) {
            try {
                LocalDate parsed = LocalDate.parse(text, formatter);
                return Timestamp.valueOf(parsed.atStartOfDay());
            } catch (Exception ignored) {
                // Intentionally ignore and try next pattern
            }
        }

        throw new IllegalArgumentException("Unable to parse TIMESTAMP from: " + text);
    }
}
