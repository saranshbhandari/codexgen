package com.test.dataflowengine.processors.taskprocessors.helpers;

import com.test.dataflowengine.models.tasksettings.subsettings.SourceDestinationMapping;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.sql.Array;
import java.sql.Date;
import java.sql.SQLXML;
import java.sql.Struct;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Centralised, optimised datatype conversion between source and destination.
 *
 * Typical usage:
 *   String srcVendor  = resolveDbVendor(settings.getSource());
 *   String destVendor = resolveDbVendor(settings.getDestination());
 *
 *   DataConverter.ConversionPlan plan =
 *       DataConverter.prepareConversionPlan(settings.getMappings(), srcVendor, destVendor);
 *
 *   DataConverter.convertBatchInPlace(batch, plan);
 *
 * Keys in the map remain the same (source column names). Only values are converted.
 */
@Slf4j
public final class DataConverter {

    private DataConverter() {
        // utility class
    }

    // ========================================================================
    // Public API
    // ========================================================================

    public static final class ConversionPlan {
        private final List<ColumnPlan> columns;

        private ConversionPlan(List<ColumnPlan> columns) {
            this.columns = columns;
        }

        boolean isEmpty() {
            return columns == null || columns.isEmpty();
        }
    }

    private static final class ColumnPlan {
        private final String sourceColumnName;
        private final LogicalType targetType;

        private ColumnPlan(String sourceColumnName, LogicalType targetType) {
            this.sourceColumnName = sourceColumnName;
            this.targetType = targetType;
        }
    }

    public static ConversionPlan prepareConversionPlan(
            List<SourceDestinationMapping> mappings,
            String sourceVendor,
            String destVendor) {

        if (mappings == null || mappings.isEmpty()) {
            return new ConversionPlan(Collections.emptyList());
        }

        List<ColumnPlan> cols = new ArrayList<>();

        for (SourceDestinationMapping mapping : mappings) {
            String srcCol = mapping.getSourceColumnName();
            if (srcCol == null || srcCol.isBlank()) {
                continue;
            }

            LogicalType destLogical = inferLogicalType(mapping.getDestinationColumnType(), destVendor);
            LogicalType srcLogical  = inferLogicalType(mapping.getSourceColumnType(), sourceVendor);

            LogicalType target = destLogical != LogicalType.UNKNOWN ? destLogical : srcLogical;

            if (target == LogicalType.UNKNOWN) {
                continue;
            }

            // Keep STRING conversion as no-op (your original optimisation)
            if (target == LogicalType.STRING) {
                continue;
            }

            cols.add(new ColumnPlan(srcCol, target));
        }

        return new ConversionPlan(Collections.unmodifiableList(cols));
    }

    public static void convertBatchInPlace(
            List<Map<String, Object>> rows,
            ConversionPlan plan) {

        if (rows == null || rows.isEmpty() || plan == null || plan.isEmpty()) {
            return;
        }

        for (Map<String, Object> row : rows) {
            if (row == null || row.isEmpty()) {
                continue;
            }

            for (ColumnPlan cp : plan.columns) {
                Object raw = row.get(cp.sourceColumnName);
                if (raw == null) {
                    continue;
                }

                try {
                    Object converted = convertToTarget(raw, cp.targetType);
                    row.put(cp.sourceColumnName, converted);
                } catch (IllegalArgumentException ex) {
                    log.trace(
                            "Data conversion failed for column '{}', value='{}'. Keeping original. Cause={}",
                            cp.sourceColumnName,
                            raw,
                            ex.getMessage()
                    );
                }
            }
        }
    }

    // ========================================================================
    // Logical types & inference
    // ========================================================================

    private enum LogicalType {
        STRING,
        INTEGER,
        LONG,
        DECIMAL,
        BOOLEAN,
        DATE,
        TIMESTAMP,

        // Added:
        JSON,
        XML,
        ARRAY,
        STRUCT,

        UNKNOWN
    }

    /**
     * Map DB/vendor specific type name to logical type.
     */
    private static LogicalType inferLogicalType(String dbType, String vendor) {
        if (dbType == null) {
            return LogicalType.UNKNOWN;
        }

        String type = dbType.trim();
        if (type.isEmpty()) {
            return LogicalType.UNKNOWN;
        }

        // Strip length/precision: VARCHAR2(100) -> VARCHAR2
        int paren = type.indexOf('(');
        if (paren > 0) {
            type = type.substring(0, paren);
        }
        type = type.toUpperCase(Locale.ROOT);

        // Generic hints (works for file sources)
        if ("STRING".equals(type) || "TEXT".equals(type)) return LogicalType.STRING;
        if ("DATE".equals(type)) return LogicalType.DATE;
        if ("DATETIME".equals(type)) return LogicalType.TIMESTAMP;
        if ("TIMESTAMP".equals(type)) return LogicalType.TIMESTAMP;
        if ("BOOL".equals(type) || "BOOLEAN".equals(type)) return LogicalType.BOOLEAN;
        if ("INT".equals(type) || "INTEGER".equals(type)) return LogicalType.INTEGER;
        if ("LONG".equals(type)) return LogicalType.LONG;
        if ("NUMBER".equals(type) || "DECIMAL".equals(type) || "NUMERIC".equals(type)) return LogicalType.DECIMAL;

        // New generic hints:
        if ("JSON".equals(type)) return LogicalType.JSON;
        if ("XML".equals(type) || "XMLTYPE".equals(type)) return LogicalType.XML;
        if ("ARRAY".equals(type)) return LogicalType.ARRAY;
        if ("STRUCT".equals(type) || "OBJECT".equals(type) || "UDT".equals(type)) return LogicalType.STRUCT;

        if (vendor != null) {
            String v = vendor.toUpperCase(Locale.ROOT);

            // ORACLE
            if (v.contains("ORACLE")) {
                if (type.startsWith("VARCHAR") || type.contains("CLOB") || type.startsWith("CHAR")) return LogicalType.STRING;
                if (type.startsWith("TIMESTAMP")) return LogicalType.TIMESTAMP;
                if ("DATE".equals(type)) return LogicalType.DATE;
                if ("NUMBER".equals(type)) return LogicalType.DECIMAL;

                // Oracle-specific type names often appear like these:
                if ("XMLTYPE".equals(type)) return LogicalType.XML;
                if ("JSON".equals(type)) return LogicalType.JSON;

                // If mapping contains "VARRAY"/"TABLE"/"NESTED TABLE" etc, treat as ARRAY
                if (type.contains("VARRAY") || type.contains("TABLE")) return LogicalType.ARRAY;

                // Many UDTs come with custom type name; you may pass "MY_SCHEMA.MY_TYPE"
                // We can't confidently infer any custom identifier, so only do minimal inference:
                if (type.contains(".")) return LogicalType.STRUCT;
            }

            // MYSQL
            if (v.contains("MYSQL")) {
                if (type.startsWith("VARCHAR") || type.startsWith("CHAR") || type.contains("TEXT")) return LogicalType.STRING;
                if ("INT".equals(type) || "MEDIUMINT".equals(type) || "SMALLINT".equals(type)) return LogicalType.INTEGER;
                if ("BIGINT".equals(type)) return LogicalType.LONG;
                if ("TINYINT".equals(type)) return LogicalType.INTEGER;
                if (type.startsWith("DECIMAL") || type.startsWith("NUMERIC") || type.startsWith("DOUBLE") || type.startsWith("FLOAT")) return LogicalType.DECIMAL;
                if ("DATE".equals(type)) return LogicalType.DATE;
                if (type.startsWith("DATETIME") || type.startsWith("TIMESTAMP")) return LogicalType.TIMESTAMP;
                if (type.startsWith("JSON")) return LogicalType.JSON;
            }

            // SQL SERVER
            if (v.contains("SQLSERVER") || v.contains("SQL_SERVER") || "MSSQL".equals(v)) {
                if (type.startsWith("VARCHAR") || type.startsWith("NVARCHAR") || type.startsWith("CHAR") || type.contains("TEXT")) return LogicalType.STRING;
                if ("INT".equals(type) || "SMALLINT".equals(type) || "TINYINT".equals(type)) return LogicalType.INTEGER;
                if ("BIGINT".equals(type)) return LogicalType.LONG;
                if (type.startsWith("DECIMAL") || type.startsWith("NUMERIC") || type.startsWith("MONEY")) return LogicalType.DECIMAL;
                if ("DATE".equals(type)) return LogicalType.DATE;
                if (type.startsWith("DATETIME") || type.startsWith("SMALLDATETIME") || type.startsWith("DATETIME2")) return LogicalType.TIMESTAMP;
                if ("BIT".equals(type)) return LogicalType.BOOLEAN;
                if ("XML".equals(type)) return LogicalType.XML;
            }
        }

        return LogicalType.UNKNOWN;
    }

    // ========================================================================
    // Converters
    // ========================================================================

    private static Object convertToTarget(Object value, LogicalType target) {
        return switch (target) {
            case STRING -> value.toString();
            case INTEGER -> toInteger(value);
            case LONG -> toLong(value);
            case DECIMAL -> toDecimal(value);
            case BOOLEAN -> toBoolean(value);
            case DATE -> toSqlDate(value);
            case TIMESTAMP -> toSqlTimestamp(value);

            // Added:
            case JSON -> toJsonText(value);
            case XML -> toXmlText(value);
            case ARRAY -> toArrayValue(value);
            case STRUCT -> toStructValue(value);

            case UNKNOWN -> value;
        };
    }

    private static Integer toInteger(Object value) {
        if (value instanceof Integer integer) return integer;
        if (value instanceof Number number) return number.intValue();

        String text = value.toString().trim();
        if (text.isEmpty()) return null;
        return Integer.valueOf(text);
    }

    private static Long toLong(Object value) {
        if (value instanceof Long longValue) return longValue;
        if (value instanceof Number number) return number.longValue();

        String text = value.toString().trim();
        if (text.isEmpty()) return null;
        return Long.valueOf(text);
    }

    private static BigDecimal toDecimal(Object value) {
        if (value instanceof BigDecimal bigDecimal) return bigDecimal;

        // If you want to avoid double rounding issues for Long/Integer, handle them first:
        if (value instanceof Long l) return BigDecimal.valueOf(l);
        if (value instanceof Integer i) return BigDecimal.valueOf(i);

        if (value instanceof Number number) {
            return BigDecimal.valueOf(number.doubleValue());
        }

        String text = value.toString().trim();
        if (text.isEmpty()) return null;
        return new BigDecimal(text);
    }

    private static Boolean toBoolean(Object value) {
        if (value instanceof Boolean bool) return bool;

        String text = value.toString().trim().toLowerCase(Locale.ROOT);
        if (text.isEmpty()) return null;

        if ("1".equals(text) || "y".equals(text) || "yes".equals(text) || "true".equals(text)) return Boolean.TRUE;
        if ("0".equals(text) || "n".equals(text) || "no".equals(text) || "false".equals(text)) return Boolean.FALSE;

        return Boolean.valueOf(text);
    }

    // ========================================================================
    // JSON / XMLTYPE
    // ========================================================================

    /**
     * Normalize JSON to a String so DB writers can store it in JSON/CLOB/VARCHAR columns.
     */
    private static String toJsonText(Object value) {
        if (value == null) return null;

        // Common cases:
        if (value instanceof String s) return s;
        if (value instanceof byte[] bytes) return new String(bytes, StandardCharsets.UTF_8);

        // If some drivers return vendor JSON objects, toString() often yields JSON text.
        return value.toString();
    }

    /**
     * Normalize XML to a String (handles SQLXML and Oracle XMLType via reflection).
     */
    private static String toXmlText(Object value) {
        if (value == null) return null;

        if (value instanceof String s) return s;

        if (value instanceof SQLXML xml) {
            try {
                return xml.getString();
            } catch (Exception e) {
                throw new IllegalArgumentException("Unable to read SQLXML: " + e.getMessage());
            }
        }

        // Oracle XMLType sometimes comes as oracle.xdb.XMLType
        // We avoid hard dependency using reflection.
        String cn = value.getClass().getName();
        if ("oracle.xdb.XMLType".equals(cn)) {
            // Try getStringVal() first, then fallback to toString()
            try {
                Object out = value.getClass().getMethod("getStringVal").invoke(value);
                return out == null ? null : out.toString();
            } catch (Exception ignored) {
                // fallback
            }
        }

        return value.toString();
    }

    // ========================================================================
    // ARRAY / STRUCT (Oracle UDTs)
    // ========================================================================

    /**
     * Normalize JDBC Array to a Java Object[] (recursively normalizing STRUCT/ARRAY inside).
     */
    private static Object toArrayValue(Object value) {
        if (value == null) return null;

        if (value instanceof Object[] arr) {
            return normalizeArray(arr);
        }

        if (value instanceof Array jdbcArray) {
            try {
                Object arr = jdbcArray.getArray(); // usually Object[]
                if (arr instanceof Object[] a) {
                    return normalizeArray(a);
                }
                return arr;
            } catch (Exception e) {
                throw new IllegalArgumentException("Unable to read JDBC Array: " + e.getMessage());
            }
        }

        // If driver already gave a List, normalize elements
        if (value instanceof List<?> list) {
            List<Object> out = new ArrayList<>(list.size());
            for (Object o : list) out.add(normalizeUdtValue(o));
            return out;
        }

        return value;
    }

    /**
     * Normalize JDBC Struct to a Map so it can be serialized/stored/handled consistently.
     *
     * NOTE: Standard JDBC doesn't expose attribute names, only values.
     * We return:
     *   { "__type": "<SQL type name>", "__attributes": [ ... ] }
     *
     * If you want real attribute names, we can add Oracle-specific metadata via OracleConnection,
     * but that requires a DB call or driver APIs.
     */
    private static Object toStructValue(Object value) {
        if (value == null) return null;

        if (value instanceof Struct struct) {
            try {
                Object[] attrs = struct.getAttributes();
                Map<String, Object> m = new LinkedHashMap<>();
                m.put("__type", struct.getSQLTypeName());
                m.put("__attributes", normalizeArray(attrs));
                return m;
            } catch (Exception e) {
                throw new IllegalArgumentException("Unable to read JDBC Struct: " + e.getMessage());
            }
        }

        // Some drivers may give a Map already
        if (value instanceof Map<?, ?> map) {
            return map;
        }

        return value;
    }

    private static Object[] normalizeArray(Object[] arr) {
        Object[] out = new Object[arr.length];
        for (int i = 0; i < arr.length; i++) {
            out[i] = normalizeUdtValue(arr[i]);
        }
        return out;
    }

    private static Object normalizeUdtValue(Object v) {
        if (v == null) return null;
        if (v instanceof Struct) return toStructValue(v);
        if (v instanceof Array) return toArrayValue(v);
        if (v instanceof SQLXML) return toXmlText(v);
        return v;
    }

    // ========================================================================
    // Date / time parsing  (THIS PRESERVES YOUR EXISTING FUNCTIONALITY)
    // ========================================================================

    private static final List<DateTimeFormatter> DATE_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE,                         // 2024-12-05
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),                // 05/21/2024
            DateTimeFormatter.ofPattern("dd/MM/yyyy"),
            DateTimeFormatter.ofPattern("dd-MMM-yyyy", Locale.ENGLISH)
    );

    private static final List<DateTimeFormatter> DATE_TIME_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE_TIME,                    // 2024-12-05T10:22:33
            DateTimeFormatter.ISO_OFFSET_DATE_TIME,
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"),       // 05/21/2024 10:22:33
            DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss", Locale.ENGLISH)
    );

    private static Date toSqlDate(Object value) {
        if (value instanceof Date sqlDate) return sqlDate;
        if (value instanceof java.util.Date utilDate) return new Date(utilDate.getTime());
        if (value instanceof LocalDate localDate) return Date.valueOf(localDate);
        if (value instanceof LocalDateTime localDateTime) return Date.valueOf(localDateTime.toLocalDate());

        String text = value.toString().trim();
        if (text.isEmpty()) return null;

        // Try pure date patterns first
        for (DateTimeFormatter formatter : DATE_FORMATS) {
            try {
                LocalDate parsed = LocalDate.parse(text, formatter);
                return Date.valueOf(parsed);
            } catch (Exception ignored) {
                // try next
            }
        }

        // If the string actually has time, parse and drop time part
        for (DateTimeFormatter formatter : DATE_TIME_FORMATS) {
            try {
                LocalDateTime parsed = LocalDateTime.parse(text, formatter);
                return Date.valueOf(parsed.toLocalDate());
            } catch (Exception ignored) {
                // try next
            }
        }

        // Offset date time fallback (keeps your original behavior)
        try {
            OffsetDateTime odt = OffsetDateTime.parse(text);
            LocalDate localDate = odt.atZoneSameInstant(ZoneId.systemDefault()).toLocalDate();
            return Date.valueOf(localDate);
        } catch (Exception ignored) {
            // throw below
        }

        throw new IllegalArgumentException("Unable to parse DATE from: " + text);
    }

    private static Timestamp toSqlTimestamp(Object value) {
        if (value instanceof Timestamp timestamp) return timestamp;
        if (value instanceof java.util.Date utilDate) return new Timestamp(utilDate.getTime());
        if (value instanceof LocalDateTime localDateTime) return Timestamp.valueOf(localDateTime);
        if (value instanceof LocalDate localDate) return Timestamp.valueOf(localDate.atStartOfDay());

        String text = value.toString().trim();
        if (text.isEmpty()) return null;

        // Try datetime patterns
        for (DateTimeFormatter formatter : DATE_TIME_FORMATS) {
            try {
                LocalDateTime parsed = LocalDateTime.parse(text, formatter);
                return Timestamp.valueOf(parsed);
            } catch (Exception ignored) {
                // try next
            }
        }

        // ISO offset timestamp
        try {
            OffsetDateTime odt = OffsetDateTime.parse(text);
            return Timestamp.from(odt.toInstant());
        } catch (Exception ignored) {
            // try date-only
        }

        // Maybe only a date string â€“ treat as midnight
        for (DateTimeFormatter formatter : DATE_FORMATS) {
            try {
                LocalDate parsed = LocalDate.parse(text, formatter);
                return Timestamp.valueOf(parsed.atStartOfDay());
            } catch (Exception ignored) {
                // try next
            }
        }

        throw new IllegalArgumentException("Unable to parse TIMESTAMP from: " + text);
    }
}
